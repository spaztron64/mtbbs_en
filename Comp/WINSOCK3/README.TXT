===========================================================================
【ソ フ ト名】  Delphi 2.0によるWinsock系サンプルアプリケーション
【登  録  名】  DWINSCK2.LZH
【バイト  数】  
【検索  キー】  1:WIN32   2:WINSOCK   3:Delphi   4:TCPIP
【著作権  者】  GED02523  大坪保行 (yuki)
【対応  環境】  Windows 95/ Windows NT3.5x 以降
【動作  確認】  FMV-5100NL/W                         Windows95
                FMV-560D3                            Windows95      SP1
                自作IBM互換機(MS-433 Cyrix5x86-100)  Windows NT3.51 SP3
                自作IBM互換機(MS-433 Cyrix5x86-100)  Windows NT4.0bata2
【開発  言語】  Delphi 2.0J Developer版
【掲  載  日】  1996/09/13
【作成  方法】  LHA にて解凍を行う
【ｿﾌﾄｳｪｱ種別】  フリーソフトウェア
【転載  条件】  転載、販売用に使用される方は、事前にメールを下さい．
　　　　　　　　若干の条件がございます．
                転載等は自由です。ただし、利用者の自己責任にて利用して下さい。
　　　　　　　　質問等は、Niftyserve/SBORLAND/#19 会議室のみで受け付けます。
　　　　　　　　クイック・レスポンスは期待しないでください。

【質問の広場】  ニフティーサーブ SBORLAND #9会議室
【メール宛先】  GED02523@niftyserve.or.jp                または
                yasuyuki@msn.com
===========================================================================

はじめに、
  ３２ビット版DWINSOCKをダウンロードしていただき、誠にありがとうございます。
本プログラムが少しでもみなさまの参考にでもなれば幸いです。

【特徴】
  Windows95やWindowsNTで標準機能の一つとしてTCP/IPによる通信機能があります。
Delphi 2.0を使って、この通信機能を利用したサンプルプログラム集です。個々のプ
ログラムについては別途詳細を見て頂くとして、このサンプルの目的をお話します。

  基本的には、Delphi1.0で作成したDWINSOCK.LZH(掲載箇所は下記参照)と変わらな
いのですが、2.0になってBorland社よりWinsock.pasを提供されるようになりました
ので、提供ユニットファイルに対応するように変更しました。
  特徴としては、最近マイクロソフト社から提供されているInternet Control Packs
を使用しないで、直接APIをコールして動作するように作っています。ソースコードも
添付していますので、興味のある方には参考になるかと思います。
  ちなみに、１６ビット版はNiftyserveの以下のところにあります。

    Delphi 1.0J 16Bit edition for Windows 3.1x/95 and Windows NT3.x
      Niftyserve SBORLAND
                 LIB   2    Delphi/Turbo Pascal/for Windows
                 No. 148    DWINSOCK.LZH DELPHIでTCP/IP通信する


【使用法】
   特にインストーラー等は用意をしていません。私の開発環境をそのまま圧縮しました
ので、適当なディレクトリ下にて、ディレクトリ付きで解凍して下さい。利用される方
との環境が異なるかと思いますが、ディレクトリを有効にして解凍してください。御不
満かとは思いますが、複数プロジェクトをまとめたため、このような仕様となりました
。ご容赦下さい。したがって、ディレクトリ付きで利用環境にインストールされますで
、環境にあわせて若干の変更が必要と思います。

(1)DWINSOCK.LZH をディレクトリを有効にして解凍します。
   すると、以下のディレクトリに展開されます。
   \src\winsock32
   \src\winsock32\Check Winsock
   \src\winsock32\Close Sockets
   \src\winsock32\Create Sockets
   \src\winsock32\Tester

適宜自分の好きなディレクトリに移動します。コピーした場合、
\src\winsock32 以下を消去するのを忘れないでください。

(2)\src\winsock32のディレクトリにSocklib.dcuが解凍されていますので、パスの通っ
たライブラリへ移してください。例えば、
     \Program Files\Borland\Delphi\Lib
へ、移動させてください。

(3)コンパイルする前に、[オプション(O)|プロジェクト(P)...]コマンドを選択して、
みなさんの利用環境にあわせて、プロジェクトを変更します。
<Directories/Conditions>タブをクリックし、検索パス(S)に ..\. を指定します。
TESTER.DPR の、\SRC を含むパス名を、'..\WINSOCK.PAS' のように相対指定します。
（必ずしもこの指定をしなくてもいいかもしれません。）

         コンパイルではなく、再構築できることを確認します。

===========================================================================

ダウンロードファイル名：DWINSCK2.LZH

【同梱ファイルのリスト】

Listing of archive : dwinsck2.lzh

  Name          Original    Packed  Ratio   Date     Time   Attr Type  CRC
--------------  --------  -------- ------ -------- -------- ---- ----- ----
+ CHECKER.RES        876       376  42.9% 96-09-04 22:54:20 a--w -lh5- D9FD
+ CHKMAIN.PAS       1472       576  39.1% 96-09-01 01:10:36 a--w -lh5- 123F
+ CHKMAIN.dfm       3439      1265  36.8% 96-09-04 23:59:46 a--w -lh5- 5BF5
+ Checker.dpr        207       149  72.0% 96-06-09 00:03:42 a--w -lh5- FE48
+ MAINFORM.PAS      1200       530  44.2% 96-09-01 01:12:10 a--w -lh5- 1D25
+ SHUTSOCK.RES       876       299  34.1% 96-02-14 16:28:08 a--w -lh5- 9DD8
+ MAINFORM.dfm      2870      1031  35.9% 96-09-05 00:07:12 a--w -lh5- 6A7F
+ Shutsock.dpr       307       220  71.7% 96-06-14 23:27:10 a--w -lh5- 702E
+ MAINFORM.PAS      1826       749  41.0% 96-09-01 01:20:16 a--w -lh5- 9711
+ MKWSOCK.RES        876       284  32.4% 96-09-04 22:57:42 a--w -lh5- 76F1
+ MAINFORM.dfm      2797       959  34.3% 96-09-04 23:51:12 a--w -lh5- A1FF
+ Mkwsock.dpr        220       158  71.8% 96-09-04 22:56:58 a--w -lh5- 1768
+ MAINFORM.PAS     13053      3334  25.5% 96-09-04 23:43:00 a--w -lh5- 78B2
+ TEST001.TXT         62        36  58.1% 95-12-13 22:39:56 a--w -lh5- 30CF
+ TESTER.RES         876       350  40.0% 96-09-04 23:27:34 a--w -lh5- 0785
+ MAINFORM.dfm      4323      1494  34.6% 96-09-04 23:49:10 a--w -lh5- 9287
+ Tester.dpr         236       167  70.8% 96-09-04 23:07:00 a--w -lh5- 3DC0
+ Packet.pas        3014       836  27.7% 96-09-04 23:08:06 a--w -lh5- 96FF
+ GETINI.PAS         777       426  54.8% 95-12-14 17:38:18 a--w -lh5- BAC8
+ SOCKET.DPR         168       125  74.4% 95-11-15 13:43:58 a--w -lh5- DE31
+ SOCKET.RES         794       331  41.7% 96-02-05 23:08:56 a--w -lh5- 5B24
+ WINSOCK.RES        794       331  41.7% 95-10-20 14:17:02 a--w -lh5- 5B24
--------------  --------  -------- ------ -------- -------- ---- ----- ----
    22 files       41063     14026  34.2% 96-09-11 12:45:38

===========================================================================

【ＦＡＱ】
Ｑ１：ＶＣ＋＋やＳＤＫが必要ですか。
Ａ１：ＶＣ＋＋やＳＤＫは、必要ありません。Delphiの開発環境だけでサーバおよび
      クライアントプログラムが作成できます。

Ｑ２：ＴＣＰ／ＩＰ関連の市販パッケージが必要ですか。
Ａ２：Windows95やWindows NTでは必要ありません。Windows3.1xの頃は、市販のTCP/IP
      パッケージを必要としましたが、Windows95やWindows NTでは標準でWINSOCKがOS
      に装備されています。したがって、動作環境としては、新たに購入する物はあり
      ません。

Ｑ３：Unixと通信できますか。
Ａ３：DWINSOCK.LZHおよびDWINSCK2.LZHともに、問題無く通信しています。
      参考までに、当方で通信確認した装置を示します。

　1)Unix系
　　Sunmicrosystems Station 5, 10 and 20          SunOS   4.1.x
　　                                              Solaris 2.5x
    IBM-PC/AT互換機(DOS/V機と呼ばれるもの)        FreeBSD 2.x
                                                  Linux   1.2.13 or later

　2)DOS/Windows系
    Winsock 1.1 および Winsock 2.0をインストールしているもの。
　　IBM-PC/AT 互換機　や NEC PC-98シリーズのハードウェアは問いません。
　　当方で動作確認済みです。

Ｑ４：動作環境はなんですか。
　作成したUNITを用いたアプリケーションは、以下の環境で動作確認しています。

　　1)WINSOWS95
　　　標準WINSOCK

　　2)WINDOWS NT3.5x
　　　標準WINSOCK

    3)WINDOWS NT4.0 beta2
　　　標準WINSOCK


本プログラムには、Unix系には無いWindows固有の非同期socket関数を使用しています。
WSASyncSelect()やメッセージの使い方の参考になるかと思います。


【作者から】
   利用制限などはありません。自由に使ってください。また、Socklib. pas等のライ
ブラリに、こんな機能が欲しいなどの意見がありましたらメイルなどを頂けたら幸い
と思います。
　Delphiを入手して比較的早い時期に作成しDWINSOCK.LZHに若干手を加えたものですの
で、相変わらず非常に見苦しいプログラムになっています。本当は恥ずかしくてお見せ
できるものではないのですが、いまさら全てを作り直すのも面倒なのでそのままにして
います。このような物でも、あれば参考になるかなと思い公開することにしました。
　当方では、当UNITを利用して作成したツールを複数のＰＣ上で開発環境の一つとして
使用しています。したがって、動作実績としては、十分かと考えています。実を言うと
予算上、開発者全員にワークステーションを配布することができませんので、否応なく
ＰＣでツールを内製しています。LinuxやFreeBSD等の選択肢も無くはないのですが、ド
キュメント作成まで考えると全ての作業をＰＣ１台でできる方が望ましいとの判断もあ
ります。
  疑問点などは、SBORLAND #9 会議室にて対応します。ただ、本業がこの手の仕事から
離れていますので、皆さんの質問に十分お答えすることができないことがありますので
、あらかじめ御了承お願いします。

  最近は、マイクロソフト社よりInternet Control Pasks として、TCP/IP関連のOCXが
インターネットから無料でダウンロードできるようになり、直接APIを操作してアプリ
ケーションを作成する必要がなくなったと思います。MSICPを利用することにより、特
にクライアント・アプリケーションに関してはAPI操作の必要性を見出せませんが、高
度なサーバー・アプリケーションを作成するには、まだまだAPIの操作は必要です。そ
れに、ユーザー用のアプリケーションとしての必要性については疑問ですが、ICMP関連
のOCXは提供されていないので、ここの部分もAPI操作が必要となっています。
  最後に、Ping(ICMP-Echo)について近日中にコンポーネントを発表できると思います。

【重要なお知らせ】
  本マニュアルのすべての内容は著作権によって保護されています。本書の内容の一部
または全部を、無断で転載することは禁じられています。

  Ｃｏｐｙｒｉｇｈｔ（Ｃ） １９９６  Ｙａｓｕｙｕｋｉ Ｏｔｓｕｂｏ
  Ａｌｌ ｒｉｇｈｔｓ ｒｅｓｅｒｖｅｄ
  著作者： 大坪 保行

  本マニュアルにおいて説明されている本ソフトウェアも同様に著作権法により保護さ
れています。ただし、本ソフトウェアに関する著作権は放棄しませんが、利用や配布に
ついては無料で自由にしたいと考えています。また、本ソフトウェアならびに本ドキュ
メントを運用した結果の影響についてはいっさい責任を負いかねますのでご了承くださ
い。利用者の責任において使用してください。
  本ソフトウェアの仕様は予告無しに変更することがあります。
==============================================================================
プログラム：Ｃｈｅｃｋｅｒについて説明します。

目的：本プログラムは、動作環境であるＰＣにてWinsockが利用できるか確認するために
　　　作成したものです。
　　　また、利用するWinsockの特性を確認することができます。特に重要な要素は、
　　　リソース数です。この場合の重要リソースとは、作成できるソケット数のことです　　　。

chkmain.pasの抜粋をもとに説明します。

説明：Winsockを使用するためには、必ず行う手続きがあります。それは、
　　　WSAStartup()とWSACleanupです。それぞれの手続きは必ずペアで
　　　使用します。

procedure TForm1.OkClick(Sender: TObject);

var
{ Winsockの内部情報へのポインタを確保します。}
  WsaData: PWSADATA;
begin
  if Ok.Default then halt
          else begin
            Ok.Default := True;
            Ok.Caption := 'OK';

{ Winsockの内部情報を格納する領域を確保します。}
            New(WsaData);

{ Winsockを初期化し、情報を獲得します。 }
{　戻り値=  0 : 初期化成功、Winsockを使用することができます。}
{        <> 0 : 失敗、エラー理由が設定されています。}
{　　　　　　　 エラー理由は、Winsock.incを参照してください。}
            if (WSAStartup($0101, WsaData) = 0) then begin

               { Check return value of WSAStartup }

{ コンパイルして実行結果を見て頂くと分かりますが、それぞれ以下のような
　値が設定されています。}
{  wVersion      : バージョン番号}
{　szSystemStatus: Winsockの動作状態}
{　iMaxSockets   : TCPソケットの最大作成数}
{　iMaxUdpDg     : UDPソケットの最大作成数}
{　szDescription : その他、メーカの特記事項}
{注意事項:変数名で頭に sz と付いているものはヌルターミネート型の文字列です。}

               with Form1, WsaData^ do begin
                   Label7.Captiongint(wVersion), 4);
                   Label8.Caption := szSystemStatus;
                   Label9.Caption := IntToStr(iMaxSockets);
                   Label10.Caption := IntToStr(iMaxUdpDg);
                   Label12.Caption := StrPas(szDescription);
               end;

{ Winsockの使用を終了し、リソースを開放します。}
               WSACleanUp;

            end;
            Dispose(WsaData);
  end;
end;

=============================================================================

プログラム：Ｍｋｓｏｃｋについて説明します。

目的：Ｍｋｓｏｃｋは、利用するWinsockにて作成できるソケット数が実際に何個まで
　　　できるのか確認するために作成したものです。ただし、５１２個作成できれば
　　　十分と考え、最大作成数の上限を５１２としています。
　　　　ちなみに、私が実験した範囲では以下のようになりました。

       Windows 3.1 + DEC Pathworks : SOCK_STREAM   16
                   + PC/TCP        : SOCK_STREAM    8
                   + CenterTCP     : SOCK_STREAM    8
　　　　　　　　　 + Chamereon　　 : SOCK_STREAM　　8
       Windows 95                  : SOCK_STREAM  256
       Windows NT3.5               : SOCK_STREAM 1024+

      Windows NTに関しては延々と作成していたので、途中で中断しました。自作する
　　　アプリケーションに1000個以上のソケットが同時に必要になるとは考えていない
　　　ためです。
　　　Windows 3.1に関しては、ＴＣＰ／ＩＰパッケージに添付しているWinsockのソケ
　　　ット数は、８〜１６となっているみたいです。

=============================================================================

プログラム：ｓｈｕｔｓｏｃｋについて説明します。

目的：Ｓｈｕｔｓｏｃｋは、強制的に使用中のソケットをクローズし、Winsockをクリー
　　　ンアップします。
　　　プログラム開発中は、実行を中断することがよくあります。しかし、実行を中断
      するとリソースが確保されたままになり、Windows動作を不安定にさせます。ま
      してや、ソケットはCheckerの結果のように希少資源であり、アプリケーション
      とは別のレイヤで動作しています。不運にも宙ぶらりんのソケット宛にデータが
      飛んできた場合には、Windowsはハングアップします。
      この状況を防ぐために、Shutsockを使用します。

　　　　　　　　　　　　　　　＜実行中断、即Shutsock !＞

　　　　なお、このプログラムは、Windows 95に対して有効です。
　　　Windows NTでは、正しく動作しません。Windows NTは、各リソースに所有者ﾀｸﾞ
　　　を付けていますので、所有するアプリケーションがいなくなる（終了する）と
　　　Windows NT側でクリーンアップ処理をしてくれます。

注意：このプログラムは、Windows3.1やWindows95が厳密（厳格）なリソース管理を行
      っていないことを利用しています。したがって、ｆｔｐやｔｅｌｎｅｔ等の他の
      アプリケーションが動作中ですと、それらのアプリケーﾄいるソケットもクロー
      ズされます。ということは、死んでしまいます。

==============================================================================

プログラム：Ｔｅｓｔｅｒについて説明します。

目的：Ｔｅｓｔｅｒは、弊社の進入社員が作成するプログラムの接続試験用に作成
　　　しました。したがって、TCP/IPで通信する為のリファレンス的な位置付けと
　　　して利用しています。
　　　　上記の目的を果たすため、このプログラムはサーバ機能とクライアント機能
　　　の両方を備えています。

利用方法：
　　　　起動すると、サーバまたはクライアントの[SOCKET]ボタンが押せるようにな
　　　　っています。サーバ側のボタンを押すとサーバ機能として動作します。逆に、
　　　　クライアント側を押すとクライアント機能として動作します。

　　サーバ側から説明します。

　　　　1)ソケットの作成
　　　　　サーバ側の[SOCKET]ボタンを押すと、セーブファイルダイアログが開きます
          。ここで、適当なディレクトリとファイル名を指定しますと、以後の通信ロ
          グがそこに記録されます。ログが不要な場合は、キャンセルします。

　　　　2)IPアドレスとポート番号の設定
　　　　　IPアドレスの設定は、loopblocalhostの何れかを選択します。なぜ
　　　　ならサーバは、接続されるのを待つため接続相手のアドレスは指定しません。
　　　　代わりに待つためのポート番号を設定します。

　　　　3)接続待ち状態にする
　　　　　[Listen]ボタンを押す。
　　　　　接続要求を受信すると自動的に接続を受け付け、コネクションを確立します。
　　　　4)データの送受信
　　　　　データを送信したい場合は、送信したいデータファイルをオープン後、
          [SEND]ボタンを押すことによりデータを送信します。データ送信は、一行単
          位で送られます。データが２行ある場合は、２回押すことにより２行送信し
          ます。
　　　　　データ形式について、データ形式の項を参照して下さい。

　　　　5)コネクション切断
　　　　　[CLOSE]ボタンを押す。通常はクライアント側から切断します。クライアント
　　　　　から切断要求を受けると、自動的に切断処理を行います。

　　クライアント側の説明をします。

　　　　1)ソケットの作成
　　　　　クライアント側の[SOCKET]ボタンを押すと、セーブファイルダイアログが開
　　　　きます。ここで、適当なディレクトリとファイル名を指定しますと、以後の通
　　　　信ログがそこに記録されます。ログが不要な場合は、キャンセルします。

　　　　2)IPアドレスとポート番号の設定
　　　　　IPアドレスの設定は、接続するサーバのホスト名またはIPアドレスを設定し
　　　　ます。ホスト名を指定する場合は、hostsファイルにホスト名を予め設定して
　　　　いる必要があります。また、サーバが接続待ちしているポート番号を設定しま
　　　　す。

　　　　3)接続要求する
　　　　　[CONNECT]ボタンを押す。
　　　　　サーバ側からaccept()されたことを受け、コネクションを確立します。

　　　　4)データの送受信
　　　　　データを送信したい場合は、送信したいデータファイルをオープン後、
          [SEND]ボタンを押すことによりデータを送信します。データ送信は、一行単
          位で送られます。データが２行ある場合は、２回押すことにより２行送信し
          ます。
　　　　　データ形式について、データ形式の項を参照して下さい。

　　　　5)コネクション切断
　　　　　[CLOSE]ボタンを押す。通常はクライアント側から切断します。
　　　　　サーバから切断要求を受けると、自動的に切断処理を行います。

データ形式：　　　　　　　　　　　　　　　　　　　　　　　　　・・
　　　　　これは、私が勝手に決めたものですので、このプログラムのみに通用します
          。以下にデータ形式の説明をします。　

　　例)
　　　　$11 $00 $01 $01 $00 $00 ; 試験データ 0123456789ABCDEFGHIJKLMNOPQ
　　　　                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        第１番目：タスク番号
        第２番目：要求ＩＤ
        第３番目：画面ＩＤ
        第４番目：装置ＩＤ
        第５番目：ユーザデータ長
        第６番目：戻り値

　　　　~~~~部分：ユーザデータ部

　　　タスク番号は、$00以外の値を設定してください。
　　　要求ＩＤは、最上位ビット(MSB)が０の場合、要求パケットと解釈し、受信したプ
　　ログラムは応答（最上位ビット(MSB)が１）を返送します。
　　最上位ビット(MSB)が１の場合、応答パケットと解釈します。応答パケットなので、
　　応答パケットは返しません。
　　　ユーザデータ長は、０または０以外を設定します。０の場合は、ユーザデータ部
    を送信しません。０以外の場合は、ユーザデータ長はプログラムにて正しく設定し
    、ユーザデータを付けて送信します。

本プログラムの動作確認方法（ＰＣ一台で大丈夫です）
　本プログラムを２個起動します。先ずはじめに、サーバ側を設定します。上記の説明
のようにサーバ用のソケットを生成し、IPアドレスをloopbackまたはlocalhostに設定
します。
  ポート番号は適当でいいです。ここでは仮に、３０００番とします。ポート番号の設
定まで終了したら、[LISTEN]を押してください。
　次に、クライアント側の設定をします。クライアント用のソケットを生成し、IPアド
レスをloopbackまたは"127.0.0.1"か装置に割り付けたlocalhostアドレスを入力して下
さい。ポート番号は、サーバに仮設定した３０００番を入力したら、[CONNECT]を押し
てください。
ステータスが"Connected"または"Connecting"になります。（なりましたか？）

　　　　ここまでくれば、ＯＫです。後は[CLOSE]して終了してください。

【ＴＩＰ１】
　本プログラムは、サーバ機能があると書きましたが、実は半端物です。どこが半端か
といいますとクライアントを１つしか受け付けないように作成されています。

　本来ですと、サーバは複数のクライアントの要求を受け付けるようになっています。
複数クライアントの要求をサポートするためには、以下のようにする必要があります。

例)
　while (TRUE) do begin
  　  Result := Listen(server_sock, 5);
    　new_sock := accept(server_sock, server_addr, SizeOf(server_addr));
    　service_form := TForm.Create(Self);
    　service_form.Start(new_sock);
　end;

のように、accept()によって新しく生成されたソケットを用いて、サービスプログラム
を起動するようにします。そして、サーバ側のソケットは、再度要求待ち処理へ戻しま
す。

【ＴＩＰ２】
　ここの処理部にて、コネクション数をカウントし、ある値で制限することにより同時
に利用できるユーザー数を限定することができます。

==============================================================================
SockLib.dcu について、
Socklibユニットのインタフェース部を以下に示します。

unit Socklib;

interface

uses Windows, Messages, Winsock;

const
  CM_WSAConnect  = WM_USER;
  CM_WSARead     = WM_USER + 1;
  CM_WSAClose    = WM_USER + 2;
  REQUESTVERSION = $0101;

(* Winsock初期化関数
   戻り値  ０：成功
           ０：エラーコード 詳細は、Ｗｉｎｓｏｃｋ.ＰＡＳを参照のこと*)
function ws_init: integer;

(* Winsock終了関数
   戻り値   True  ：クリーンアップ成功
            FALSE ：失敗                   *)
function ws_term: boolean;

(* This function is not WINSOCK API.
  This will return a IP address by giving hostname or 'xxx.xxx.xxx.xxx'.
  If 'xxx.xxx.xxx.xxx' is given, it will return a integer(32bit long) type
  value. If IP is not resolved, return will be 0(zero).
*)
function getipbyname(name:PChar) : u_long;

                                                                          以上

